// https://stackoverflow.com/questions/44149096/for-async-tests-and-hooks-ensure-done-is-called-if-returning-a-promise-en
// .then(done, done) snippet (used in a lot of the unit tests) taken from the stackover flow post. This code is to conclude the test and cover all cases when the result of an async function is required from the unit test

const mongoose = require("mongoose");
const user = require("../models/user");
const mocha = require("mocha");
const chai = require("chai");
const puid = require("puid");
const childProcess = require("child_process");
const randomWord = require("random-words");
const path = require("path");
const addProject = require("../middleware/addProject");
const getProjects = require("../middleware/getProjects");
const passwordHashing = require("../middleware/passwordHashing");
const compareHash = require("../middleware/compareHash");
const getUsecase = require("../middleware/getUsecase");
const getProject = require("../middleware/getProject");
const getUsecases = require("../middleware/getUsecases");
const changePassword = require("../middleware/changePassword");
const deleteAccount = require("../middleware/deleteAccount");
const project = require("../models/project");
const deleteProject = require("../middleware/deleteProject");
const editProject = require("../middleware/editProject");
const viewProjects = require("../middleware/viewProjects");
const checkOwner = require("../middleware/checkOwner");
const createAccount = require("../middleware/createAccount");
const runPythonCode = require("../middleware/runPythonCode");
const runJavaCode = require("../middleware/runJavaCode");
const sanitiseInput = require("../middleware/sanitiseInput");
const installPythonPackage38 = require("../middleware/installPythonPackage38");
const installPythonPackage39 = require("../middleware/installPythonPackage39");
const installPythonPackage310 = require("../middleware/installPythonPackage310");
const compileJavaCode = require("../middleware/compileJavaCode");
const runPythonCodeTest = require("../middleware/runPythonCodeTest");
const installPythonPackage39Test = require("../middleware/installPythonPackage39Test");
const staff = require("../models/staff");

const directory = __dirname;
const mainDirectory = directory.substring(0, directory.length - 5);
const javacPath14 = path.join(mainDirectory, "jdk-14.0.2.jdk", "Contents", "Home", "bin", "javac");


describe("1. Testing the password hashing function", function(){
    it("1.1 hash should not be equal to the plaintext password", function(done){
        // when a string is passed into the passwordHashing function - the return of the function should not be equal to the string passed in as the hash should hide the password so that it can be stored in the database
        let plaintextPassword = "adam";
        chai.expect(passwordHashing(plaintextPassword)).to.not.equal(plaintextPassword);
        done();
    });

    it("1.2 hash should be a string", function(done){
        // when a string is passed into the passwordHashing function - the return of the function (the hash of the string passed into the function) should be a string
        let plaintextPassword = "password123";
        chai.expect(passwordHashing(plaintextPassword)).to.be.string;
        done();
    });
});

describe("2. Testing the function that compares hashes to plaintext", function(){
    it("2.1 the hash generated by a plaintext must return true", function(done){
        // When the plaintext string and the hash of the plaintext are both passed into the compareHash function, the function should return true. The function returning true verifies that this is a valid plaintext, hash pair.
        // this will verify if the user's submitted password is equal to the hash stored in the database
        let plaintextPassword = "adam";
        // create the hash based on the plaintext password
        let hash = passwordHashing(plaintextPassword);
        let compare = compareHash(plaintextPassword, hash);
        chai.expect(compare).to.equal(true);
        done();
    });

    it("2.2 When the hash does not match the plaintext, return false", function(done){
        // When the plaintext that is passed into the compareHash function along with a hash that does not match the compareHash function should return false.
        // The function returning false indicates that this plaintext hash pair is not a match, in the application a false result will prevent the user from being authenticated when the password that they submit and the hash stored in the database does not match
        let plaintextPassword = "adam1";
        let hash = passwordHashing("adam");
        let compare = compareHash(plaintextPassword, hash);
        chai.expect(compare).to.equal(false);
        done();
    });
});

describe("3. Testing the getUsecase function - which return a usecase when given a projectId and a usecaseId", function(){
 
    it("3.1 when a correct projectId and correct usecaseId is passed in a usecase object should be returned from the database", function(done){
        // when the projectId and the usecaseId of a usecase that belongs to the project which is passed into the getUsecase function. The function should return an object, which is the database object of the usecase.
        let correctProjectId = "lgz5hozq08m823040f64auvo";
        let correctUsecaseId = "lgz5hozq08m823040f64azfk";

        getUsecase(correctProjectId, correctUsecaseId).then(function(result){
            chai.expect(result).to.be.an("object");
        }).then(done, done);
    });

    it("3.2 when a correct projectId and incorrect usecaseId is passed in an error message should be returned", function(done){
        // if the usecaseId passed into the function does not refer to any usecase stored in the database the getUsecase function should return an error message
        let correctProjectId = "lgz5hozq08m823040f64auvo";
        let incorrectUsecaseId = "123";

        getUsecase(correctProjectId, incorrectUsecaseId).then(function(result){
            chai.expect(result).to.be.equal("error - usecase does not exist");
        }).then(done, done);
    });

    it("3.3 when an incorrect projectId is passed and error message should be returned", function(done){
        let incorrectProjectId = "1";
        let correctUsecaseId = "1";

        // when an invaild project is passed into the getUsecase function, the function should return an error message
        getUsecase(incorrectProjectId, correctUsecaseId).then(function(result){
            chai.expect(result).to.be.equal("error - project does not exist");
        }).then(done, done);
    });
});

describe("4. Testing the getProject function", function(){
    it("4.1 When a valid projectId is passed in, a project is returned", function(done){
        let validProjectId = "lgz5hozq08m823040f64auvo";
        // when a valid projectId is passed into the getProject function, a projectId which refers to a project stored in the database the function returns an object of the project. This object contains all the properties which are elements in the project database schema
        getProject(validProjectId).then(function(result){
            chai.expect(result).to.be.an("object");
            // the schema of the project in the database
            chai.expect(result).to.have.property("projectId");
            chai.expect(result).to.have.property("projectDescription");
            chai.expect(result).to.have.property("programmingLanguage");
            chai.expect(result).to.have.property("programmingLanguageVersion");
            chai.expect(result).to.have.property("numberOfFiles");
            chai.expect(result).to.have.property("namingConvention");
            chai.expect(result).to.have.property("dateAdded");
            chai.expect(result).to.have.property("staffId");
            chai.expect(result).to.have.property("usecases");
        }).then(done, done);
    });

    it("4.2 When an invalid projectId is passed in, an error message is returned", function(done){
        // When a projectId is passed into and this projectId does not refer to a project stored in the database an error message is returned by the function
        let invalidProjectId = "lee91y6z05669d00623bhtm9";
        getProject(invalidProjectId).then(function(result){
            chai.expect(result).to.be.equal("error - project does not exist");
        }).then(done, done);
    });
});


describe("5. Testing the getProjects function", function(){
    //  An array containing all the projects stored in the database should be returned by the function
    it("5.1 When there are projects in the database the getProjects function should return an array of the projects stored in the database", function(done){
        getProjects().then(function(result){
            chai.expect(result).to.be.an("array");
        }).then(done, done);
    });
});

describe("6. Testing the getUsecases function", function(){
    it("6.1 When a project that does not exist is passed in an error message is returned", function(done){
        // an invalid projectId passed into the function which does not refer to a project in the database will result in the function returning an error message
        let invalidProjectId = "1";
        getUsecases(invalidProjectId).then(function(result){
            chai.expect(result).equal("error - project does not exist");
        }).then(done, done);
    });

    it("6.2 If a project has one or more usecase, the getUsecases function is return an array of usecase objects", function(done){
        // a project that contains usecases should return an array containing the usecases
        getUsecases("lhf1nqe00b084e3b6e16dx6g").then(function(result){
            chai.expect(result).to.be.an("array");
        }).then(done, done);
    });

    it("6.3 Project without any usecases returns an empty object", function(done){
        getUsecases("lg25zjoz048o9d006232vcve").then(function(result){
            // a project passed into the function should return an empty array
            chai.expect(result).to.be.empty;
        }).then(done, done);
    });

});

describe("7. Testing the addProject function", function(){
    // Adding a project with wrong credentials will never actually happen because of the client-side validation on the form. All the fields are required.
    it("7.1 Add a project with invalid credentials", function(done){
        const PUID = new puid();
        const projectId = PUID.generate();
        const staffId = "lesv29vk02tt893130envqby";

        addProject(projectId, "Test Project.", "This is the description of the invalid project.").then(function(result){
            // since invalid credentials are returned - I expect a error message to be returned
            chai.expect(result).to.equal("An error occurred when adding the project.");
        }).then(done, done);
    });

    it("7.2 Add a project with valid credentials", function(done){
        const PUID = new puid();
        const projectId = PUID.generate();
        addProject(projectId, "Testing project name", "Testing project description", ".py", "python-3.8",2, "code", "Task_1_5.py|Task_2_5.py").then(function(result){
            // when the project is added to the database the function will add it to the database
            chai.expect(result).to.equal(true);
        }).then(done, done);
    });
});

describe("8. Testing changePassword function", function(){
    // This will not happen in practise as the application uses the staffId stored in the session, but must be tested for completeness
    it("8.1 Calling changePassword function with an invalid staffId should return an error message.", function(done){
        let invalidStaffId = "124";
        let newPassword = "^^Rwz(.wCG7H,^zF";
        changePassword(invalidStaffId, newPassword).then(function(changePasswordResult){
            // When an invalid staffId is passed in an error message should be returned by the function
            chai.expect(changePasswordResult).to.equal("staff not found");
        }).then(done, done);
    });

    it("8.2 Calling changePassword function with a valid staffId", function(done){
        let validStaffId = "let91zfz0758893130744l4j";
        let newPassword = "^^Rwz(.wCG7H,^zF";
        changePassword(validStaffId, newPassword).then(function(changePasswordResult){
            // when a valid staffId is passed in which refers to a staff in the database - the staff database object will be updated and the function will return a success message
            chai.expect(changePasswordResult).to.equal("updated staff");
        }).then(done, done);
    });

});

describe("9. Testing the editProject function", function(){
    it("9.1 To try and edit a project with invalid parameters, an error message should be returned.", function(done){
        // when an invalid projectId - a project that does not exist in the database is passed into the editProject - the function will updated the project in the database and a success message will be returned
        editProject("1234").then(function(invalidEditProjectResult){
            // should return an error message but that is okay because i can distinguish between 
            chai.expect(invalidEditProjectResult).to.equal("unexpected error occured");
        }).then(done, done);
    });

    // when a valid project is passed into the editProject function, with valid parameters
    // the project is updated in the database and the function returns the updated database object
    it("9.2 When valid parameters are given to the editProject function the function should return the updated project.", function(done){
        editProject
        editProject("lgz5hozq08m823040f64auvo", "Updated Project Name", "Updated Project Description", ".java", "java-14.1", 6, "code", "Task_1_5.java|Task_2.java").then(function(validUpdateProjectResult){
            // The updated project will be a project object
            chai.expect(validUpdateProjectResult).to.be.an("object");
            chai.expect(validUpdateProjectResult).to.have.property("projectId");
            chai.expect(validUpdateProjectResult).to.have.property("projectName");
            chai.expect(validUpdateProjectResult).to.have.property("projectDescription");
            chai.expect(validUpdateProjectResult).to.have.property("programmingLanguage");
            chai.expect(validUpdateProjectResult).to.have.property("programmingLanguageVersion");
            chai.expect(validUpdateProjectResult).to.have.property("numberOfFiles");
            chai.expect(validUpdateProjectResult).to.have.property("namingConvention");
            chai.expect(validUpdateProjectResult).to.have.property("dateAdded");
            chai.expect(validUpdateProjectResult).to.have.property("staffId");
            chai.expect(validUpdateProjectResult).to.have.property("usecases");
        }).then(done, done);
    });
});

// generate a random email to create an account
let generateRandomWord = randomWord();

describe("10. Testing the createAccount function.", function(){
    it("10.1 Passing valid credentials createAccount ", function(done){
        let password = "Ilel8tUe762%";
        let email = generateRandomWord + "@gmail.com";

        // passing in a valid email and password pair to the createAccount function will result in a database object being returned by the createAccount function
        createAccount(email, password).then(function(result){
            chai.expect(result).to.be.an("object");
            chai.expect(result).to.have.property("staffId");
            chai.expect(result).to.have.property("email");
            chai.expect(result).to.have.property("password");
        }).then(done, done);
    });

    // when not alll the required arguements are passed into the function - the createAccount function should return an error message
    it("10.2 Passing invalid credentials to createAccount should return an error message", function(done){
        createAccount("test@gmail.com").then(function(result){
            chai.expect(result).to.equal("unexpected error occurred");
        }).then(done, done);
    })
});

describe("11. Testing the deleteAccount function", function(){
    // This should not ever happen in the application, because it uses the staffId stored in the session variable which will be valid
    // However, still must test for completeness
    // Should return an error message because the account does not exist but since it is already deleted the function treats the account as being deleted
    // doesnt change anything in the application - but the result of the test was important to observe this 
    it("11.1 Deleting an account which does not exist should throw an error message", function(done){
        let invalidStaffId = "1234";
        deleteAccount(invalidStaffId).then(function(deleteAccountResult){
            // This unit test fails - the error message returned by the function does not equal the one expected
            chai.expect(deleteAccountResult).to.equal("An unexpected error has occurred");
        }).then(done, done);
    });

    // deleting a valid account within the database results in the deleteAccount function return "Account deleted"
    it("11.2 Deleting an account which does exist should return delete account", function(done){
        staff.findOne({email: generateRandomWord + "@gmail.com"}).then(function(result){
            deleteAccount(result.staffId).then(function(deleteAccountResult){
                chai.expect(deleteAccountResult).to.equal("Account deleted");
            }).then(done, done);
        });
    });
});

 // a test version of the function was created - so that the time taken for the function to execture would be within the time requirements of
describe("12. Testing the runPythonCode function (the function that will be executing python code)", function(){
    it("12.1 Passing a python file without any errors into the function, should return the output of the file.", function(done){
        // when the path of a valid python file is passed into the function - the output of the function should be equal to the output of the python file passed into the function
        let filePath = path.join(__dirname, "test.py");
        let result = runPythonCodeTest([filePath], "python-3.8");
        chai.expect(result.output).include("hello world");
        done();
    });
    it("12.2 Passing a file with errors (a missing parenthesis) into the function should return the error output from executing the file", function(done){
        let filePath = path.join(__dirname, "bad_test.py");
        let result = runPythonCodeTest([filePath], "python-3.8");
        // the error of the function should include SyntaxError as there is an error in the file that is passed into the function
        chai.expect(result.error).to.include("SyntaxError");
        done();
    });
    // Test with different versions of python - the application is required to work with python3.8, 3.9 an 3.10
    it("12.3 Python code can be executing using python verison 3.8", function(done){
        // the output of running the --version command in this python environment should include Python 3.8, meaning that it code will be able to be run in python version 3.8
        let result = runPythonCodeTest(["--version"], "python-3.8");
        chai.expect(result.output).to.include("Python 3.8");
        done();
    });

    it("12.4 Python code can be executing using python verison 3.9", function(done){
        let result = runPythonCodeTest(["--version"], "python-3.9")
        // the output of running the --version command in this python environment should include Python 3.9, meaning that it code will be able to be run in python version 3.9
        // the function should return the python version that is being used Python 3.9.x
        chai.expect(result.output).to.include("Python 3.9");
        done();
    });

    it("12.5 Python code can be executing using python verison 3.10", function(done){
        // the output of running the --version command in this python environment should include Python 3.8, meaning that it code will be able to be run in python version 3.8
        // the function should return the python version that is being used Python 3.10.x
        let result = runPythonCodeTest(["--version"], "python-3.10");
        chai.expect(result.output).to.include("Python 3.10");
        done();
    });
});

describe("13. Testing the installPythonPackages function for all the versions of python" , function(){
    let packageName = "image-similarity-measures";
    it("13.1 The package should be installed on the compatible python version 3.8", function(done){
        installPythonPackage38(packageName).then(function(installPackageResult){
            // the output of the installation result should include the name of the package - an output saying that the package has been installed
            // the error should not include the name of the package because there should not be an error when installing the package on this version
            chai.expect(installPackageResult.installOutput).to.include(packageName);
        }).then(done, done);
    });
    it("13.2 The package should be installed on the compatible python version 3.9", function(done){
        installPythonPackage39(packageName).then(function(installPackageResult){
            // the output of the installation result should include the name of the package - an output saying that the package has been installed
            // the error should not include the name of the package because there should not be an error when installing the package on this version
            chai.expect(installPackageResult.installOutput).to.include(packageName);
        }).then(done, done);
    });

    it("13.3 According to the docs, this package is not compatible with python 3.10 so an error message will be returned and the package will not be installed", function(done){
        installPythonPackage310(packageName).then(function(installPackageResult){
            // according to the documentation - https://pypi.org/project/image-similarity-measures/ - the external package is not compatible with this version of python so it should not be installed
            // the output should not include the name of the package
            chai.expect(installPackageResult.installError).to.include(packageName);
        }).then(done, done);
    });
});

describe("14 Testing the runJavaCode function (the function that will be executing java code)", function(){
    it("14.1 Valid java code passed into the function will have a valid corresponding output", function(done){
        let javaDirectoryPath = path.join(__dirname, "validJava", "*.java");
        let javaFilePath = path.join(__dirname, "validJava", "test.java");
        compileJavaCode("java-14.1", javaDirectoryPath).then(function(){
            // once the java code is compiled - when a valid java file is passed into the function, the function should return 
            let result = runJavaCode("java-14.1", [javaFilePath]);
            chai.expect(result.output).to.include("hello world");
         
        }).then(done, done);
    });

    it("14.2 If invalid java code that cannot be compiled in passed into the function, a compilation error message should be returned", function(done){
        let javaDirectoryPath = path.join(__dirname, "invalidJava", "*.java");
        let javaFilePath = path.join(__dirname, "invalidJava", "test.java");
        compileJavaCode("java-14.1", javaDirectoryPath).then(function(){
            let result = runJavaCode("java-14.1", [javaFilePath]);
            // the file passed into the function contains an error therefore the function should return the error of this file
            chai.expect(result.error).to.include("error: compilation failed");
        }).then(done, done);
    });

    // when a java file with a run time error is passed in the java error message will be returned by the function
    it("14.3 If invalid java code that contains a run-time error is passed into the runJavaCode function, a run-time error message should be returned", function(done){
        let javaDirectoryPath = path.join(__dirname, "invalidJava1", "*.java");
        let javaFilePath = path.join(__dirname, "invalidJava1", "test.java");
        // compile the java code before running
        compileJavaCode("java-14.1", javaDirectoryPath).then(function(){
            let result = runJavaCode("java-14.1", [javaFilePath]);
            // there is a references to an index outside the range of the array so there is a run time error - when this file is passed into the function the function should output this error
            chai.expect(result.error).to.include("Exception");
        }).then(done, done);
    });

    // the application requires java to be run in three different versions: java 14, 17, 19
    it("14.4 Java code can be run in java version 14", function(done){
        // the -version argument in java will output the version of java that the environment is running on. The output of the function should include: java version 14.0.2
        let result = runJavaCode("java-14.1", ["-version"]);
        chai.expect(result.error).to.include(`java version "14.0.2"`);
        done();
    });

    it("14.5 Java code can be run in java version 17", function(done){
        // the -version argument in java will output the version of java that the environment is running on. The output of the function should include: java version 17.0.2
        let result = runJavaCode("java-17.1", ["-version"]);
        chai.expect(result.error).to.include(`java version "17.0.6"`);
        done();
    });

    it("14.6 Java code can be run in java version 19", function(done){
        // the -version argument in java will output the version of java that the environment is running on. The output of the function should include: java
        let result = runJavaCode("java-19.1", ["-version"]);
        chai.expect(result.error).to.include(`java version "19.0.2"`);
        done();
    });
});

describe("15. Testing the checkOwner function, which will validate which user (staff) created the project", function(){
    it("15.1 calling the checkOwner function with a matching staffId and projectId (staff created the project)", function(done){
        // the staffId passed into the function matches the staffId which is stored in the project database object. The function should return true if this is the case
        let matchingOwnerId = "lesv29vk02tt893130envqby";
        let matchingProjectId = "lfux04z006e80fc76dcxb96r";
        checkOwner(matchingProjectId, matchingOwnerId).then(function(result){
            chai.expect(result).to.equal(true);
        }).then(done, done);
    });

    it("15.2 calling the checkOwner function with a staffId and projectId that do not match (the staff member did not create the project) the function will return false", function(done){
        // the staffId passed into the function does not match the staffId which is stored in the project database object. The function should return false if this is the case
        let staffId = "lesv29vk02tt893130envqbz"
        let projectId = "lfa4kvz2040t9d00628n4yrk";
        checkOwner(projectId, staffId).then(function(result){
            chai.expect(result).to.equal(false);
        }).then(done, done);
    });

    it("15.3 calling the checkOwner function with a projectId that does not exist the function will return false", function(done){
        // if the projectId does not refer to a project that is within the database the function should return false
        let staffId = "lesv29vk02tt893130envqbz";
        let invalidProjectId = "lfa4kvz2040t9d00628n4yrl";
        checkOwner(invalidProjectId, staffId).then(function(result){
            chai.expect(result).to.equal(false);
        }).then(done, done);
    });
});

describe("16. Testing the deleteProject function", function(){
    // invalid projectId is passed into the function - this projectId does not refer to a project stored in the database - an error message should be returned by the function
    let invalidProjectId = "123";
    it("16.1 When an invalid project is passed into the function an error message should be returned", function(done){
        deleteProject(invalidProjectId).then(function(result){
            chai.expect(result).to.equal("project does not exist");
        }).then(done, done); 
    });

    it("16.2 When a valid project is passed into the function the project should be deleted from the database and 'project deleted' message should be returned to the user", function(done){
        // delete one of the projects that was added in the addProject unittest
        // since a valid project is passed into the function, this project should be deleted from the database by the function and a success message should be returned by the function
        project.findOne({projectDescription: "Testing project description"}).then(function(testProject){
            deleteProject(testProject.projectId).then(function(result){
                chai.expect(result).to.equal("project deleted");
            }).then(done, done);
        });

    });

});

describe("17. Testing the viewProjects function", function(){
    it("17.1 Passing a user with no projects into to viewProjects function should return an empty array value", function(done){
        let staffId = "len9pwhx07l79d0062277j1w";
        viewProjects(staffId).then(function(result){
            // since this staff member has not created any project an empty array will be returned
            chai.expect(result).to.be.an("array");
            chai.expect(result).to.have.lengthOf(0);
        }).then(done, done);
    });
    it("17.2 Passing a user with one or more projects, will return an array of their projects", function(done){
        let staffId = "lesv29vk02tt893130envqby";
        viewProjects(staffId).then(function(result){
            // the function should return an array of projects (which should not be empty)
            chai.expect(result).to.be.an("array");
            chai.expect(result).to.not.have.lengthOf(0);
        }).then(done, done);
    });

    // In the application an invalid staffId will not be passed in because the staffId used will be stored in the user session will be valid
    it("17.3 Passing an invalid staff id, an empty array should be returned by the project since the staff member has not projects", function(done){
        let invalidStaffId = "123";
        viewProjects(invalidStaffId).then(function(result){
            // since the the staff does not exist - they will have no projects, meaning an empty array will be returned
            chai.expect(result).to.be.an("array");
            chai.expect(result).to.have.lengthOf(0);
        }).then(done, done);
    });
});

describe("18. Testing the sanitiseInput function", function(){
    it("18.1 If the user tries to do an SQL injection attack via their input the function will return an error message", function(done){
        // https://brightsec.com/blog/sql-injection-in-mongodb-examples-and-prevention/
        // lines 509 - 513 adapted from the link above to give an example user input which contains an SQL Injection attack
        // if this input is treated as a search parameter in a mongodb query this could lead to a possible leak in data within the database(a volnerability that i need to prevent) - since this input to the function contains malicious code - the function should return an error message
        let userInput = ` $where: function() {

            return (this.product == $productData)
            
            }}`;
        let sanitiseResult = sanitiseInput(userInput);
        chai.expect(sanitiseResult).to.equal("SQL INJECTION DETECTED");
        done();
    });

    it("18.2 If the user attempts a XSS attack via their input the function will return an error message", function(done){
        // the user input that is passed into the function contains an XSS attack - the function should return an error message
        let userInput = '<script>alert(document.cookie)</script>';
        let sanitiseResult = sanitiseInput(userInput);
        chai.expect(sanitiseResult).to.equal("XSS ATTEMPT DETECTED");
        done();
    });

    it("18.3 If a valid input is passed into the function the function should return the input that was passed in", function(done){
        // a valid user input is passed into the function - the function should return the originial string
        let userInput = "validInput";
        let sanitiseResult = sanitiseInput(userInput);
        chai.expect(sanitiseResult).to.equal(userInput);
        done();
    });
});